![head.svg](https://en.wikipedia.org/wiki/Martin_Luther_University_of_Halle-Wittenberg#/media/File:Double_seal_University_of_Halle-Wittenberg.svg)

# Financial Data Analytics in Python

**Ofelya Rzayeva**</br>

M.Sc. Economics: Data Science and Policy

ofelya.rzayeva@student.uni-halle.de


# Case study: Algorithmic trading

Case study: Algorithmic trading

I am starting to explain my backtest codes.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sqlalchemy import create_engine
import requests

def get_market(instrument):
    url = "https://www.deribit.com/api/v2/public/get_book_summary_by_instrument"
    params = {
        "instrument_name": instrument
    }
    response = requests.get(url, params=params)
    if response.status_code == 200:
        data = response.json()
        print('Download market data was successful')
    else:
        print(f"Failed to retrieve data: {response.status_code}")

    market_data = pd.DataFrame(data["result"])
    market_price = int(market_data['mark_price'].values[0].round(-1))
    
    print(f"Current market price: {market_price}")
    
    return market_price

By using these code I import necessary Python libraries, including pandas for data manipulation, numpy for numerical operations, matplotlib for data visualization, SQLAlchemy for database access, and requests for making API calls to the Deribit platform.
get_market(instrument) Function:
This function is defined to retrieve the current market data for a given instrument from the Deribit API. It takes the instrument name as input and makes a GET request to the API endpoint to fetch the market data. If the request is successful, the market data is extracted and stored in a DataFrame. The current market price is then rounded to the nearest tenth and returned. The function is used later to get the market price of the specified instrument.


instrument_name = "BTC-PERPETUAL"
threshold_percentage = 2.0
market_price = get_market(instrument_name)
threshold = market_price * threshold_percentage / 100
breakout_high = market_price + threshold
breakout_low = market_price - threshold
print("Breakout prices:")
print(f"Breakout High: {breakout_high}")
print(f"Breakout Low: {breakout_low}")

The script calculates the breakout prices for the Breakout Strategy. The instrument name and threshold percentage are specified. The get_market(instrument) function is called to get the current market price. The breakout threshold is calculated by multiplying the market price by the threshold percentage divided by 100. The breakout high and low prices are determined by adding and subtracting the threshold from the market price, respectively. These calculated breakout prices are printed.

# Load the data from the database
engine = create_engine('sqlite:///07_datam.db')
ohlc_data = pd.read_sql("SELECT * FROM ohlc", engine)
ohlc_data['timestamp'] = pd.to_datetime(ohlc_data['timestamp'])  # Convert 'timestamp' to datetime format
# Calculate daily log returns
ohlc_data['Returns'] = np.log(ohlc_data['close'] / ohlc_data['close'].shift(1))

The create_engine() function is used to create a connection to the database, and the data is retrieved using a SQL query. The ohlc_data DataFrame is created with columns such as timestamp, open, high, low, close, and volume. The timestamp column is converted to a datetime format for further analysis.
The daily log returns calculation measures the percentage change in the asset's price from one day to the next.

ohlc_data['Breakout_Signal'] = 0
ohlc_data.loc[ohlc_data['close'] > breakout_high, 'Breakout_Signal'] = -1
ohlc_data.loc[ohlc_data['close'] < breakout_low, 'Breakout_Signal'] = 1
ohlc_data['Breakout_Signal'] = ohlc_data['Breakout_Signal'].fillna(method='ffill')
ohlc_data['Breakout_Strategy_Returns'] = ohlc_data['Returns'] * ohlc_data['Breakout_Signal'].shift(1).fillna(0)
ohlc_data['Breakout_Cumulative_Returns'] = (ohlc_data['Breakout_Strategy_Returns'] + 1).cumprod() - 1

The script initializes a 'Breakout_Signal' column in the DataFrame to 0. The signal for the Breakout Strategy is generated by comparing the 'close' prices with the calculated breakout high and low prices. If the 'close' price is higher than the breakout high, a short signal (-1) is generated. If the 'close' price is lower than the breakout low, a long signal (1) is generated. 

# Calculate RSI Strategy (Martin J. P., 2002)
window = 14
delta = ohlc_data['close'].diff()  # Calculate the price change between each period
gain = delta.where(delta > 0, 0)  # Calculate the gain by setting negative values to 0
loss = -delta.where(delta < 0, 0)  # Calculate the loss by setting positive values to 0
average_gain = gain.rolling(window).mean()  # Calculate the average gain over the specified window
average_loss = loss.rolling(window).mean()  # Calculate the average loss over the specified window
relative_strength = average_gain / average_loss  # Calculate the relative strength
rsi = 100 - (100 / (1 + relative_strength))  # Calculate the RSI
# Generate the signal for the RSI strategy
ohlc_data['RSI_Signal'] = np.where(rsi < 30, 1, np.where(rsi > 70, -1, 0))
# Calculate the strategy returns for the RSI strategy using the previous day's 'close' prices
ohlc_data['RSI_Strategy_Returns'] = ohlc_data['Returns'] * ohlc_data['RSI_Signal'].shift(1).fillna(0)
# Calculate cumulative returns for the RSI strategy
ohlc_data['RSI_Cumulative_Returns'] = (ohlc_data['RSI_Strategy_Returns'] + 1).cumprod() - 1

The Relative Strength Index (RSI) is calculated using the 'close' prices. The RSI measures the strength of price changes to determine overbought and oversold conditions. A window of 14 days is used for the calculation. The average gain and average loss over the window are computed, and the relative strength is derived from their ratio. The RSI value is then used to generate a signal. If the RSI is below 30, a long signal (1) is generated, indicating an oversold condition. If the RSI is above 70, a short signal (-1) is generated, indicating an overbought condition.

# Calculate Bollinger Bands (John B., 2001)
window = 20
ohlc_data['Rolling_Mean'] = ohlc_data['close'].rolling(window=window).mean()
ohlc_data['Rolling_Std'] = ohlc_data['close'].rolling(window=window).std()
# Calculate upper and lower Bollinger Bands
ohlc_data['Upper_Band'] = ohlc_data['Rolling_Mean'] + 2 * ohlc_data['Rolling_Std']
ohlc_data['Lower_Band'] = ohlc_data['Rolling_Mean'] - 2 * ohlc_data['Rolling_Std']
# Generate the signal for the Bollinger Bands strategy
ohlc_data['Bollinger_Bands_Signal'] = np.where(ohlc_data['close'] < ohlc_data['Lower_Band'], 1,
                                               np.where(ohlc_data['close'] > ohlc_data['Upper_Band'], -1, 0))
# Calculate the strategy returns for the Bollinger Bands strategy using the previous day's 'close' prices
ohlc_data['Bollinger_Bands_Strategy_Returns'] = ohlc_data['Returns'] * ohlc_data['Bollinger_Bands_Signal'].shift(1).fillna(0)
# Calculate cumulative returns for the Bollinger Bands strategy
ohlc_data['Bollinger_Bands_Cumulative_Returns'] = (ohlc_data['Bollinger_Bands_Strategy_Returns'] + 1).cumprod() - 1

Bollinger Bands are calculated using the 'close' prices with a window of 20 days. The upper and lower bands are determined based on the rolling mean and standard deviation of the 'close' prices. The strategy generates a long signal (1) if the 'close' price is below the lower Bollinger Band, indicating an oversold condition. It generates a short signal (-1) if the 'close' price is above the upper Bollinger Band.


# Calculate MACD Strategy (investopedia)
short_window = 12
long_window = 26
# Calculate short-term and long-term exponential moving averages
short_ema = ohlc_data['close'].ewm(span=short_window, adjust=False).mean()
long_ema = ohlc_data['close'].ewm(span=long_window, adjust=False).mean()
# Calculate the MACD line and the signal line
macd_line = short_ema - long_ema
signal_line = macd_line.ewm(span=9, adjust=False).mean()
# Generate the signal for the MACD strategy
ohlc_data['MACD_Signal'] = np.where(macd_line > signal_line, 1, -1)
# Calculate the strategy returns for the MACD strategy using the previous day's 'close' prices
ohlc_data['MACD_Strategy_Returns'] = ohlc_data['Returns'] * ohlc_data['MACD_Signal'].shift(1).fillna(0)
# Calculate cumulative returns for the MACD strategy
ohlc_data['MACD_Cumulative_Returns'] = (ohlc_data['MACD_Strategy_Returns'] + 1).cumprod() - 1


MACD is calculated using the 'close' prices with short and long-term windows of 12 and 26 days, respectively. The MACD line and the signal line are derived from the short-term and long-term exponential moving averages. The strategy generates a long signal (1) if the MACD line is above the signal line, indicating a bullish trend, and a short signal (-1) if the MACD line is below the signal line, indicating a bearish trend.

# Calculate Single Moving Average (SMA) Strategy (John J. M., 1999)
lookback_period = 10
ohlc_data['SMA'] = ohlc_data['close'].rolling(window=lookback_period).mean()
# Generate the signal for the SMA strategy
ohlc_data['SMA_Signal'] = np.where(ohlc_data['close'] >= ohlc_data['SMA'], 1, -1)
# Backtest the SMA strategy
ohlc_data['SMA_Strategy_Returns'] = ohlc_data['Returns'] * ohlc_data['SMA_Signal'].shift(1).fillna(0)
# Calculate cumulative returns for the SMA strategy
ohlc_data['SMA_Cumulative_Returns'] = (ohlc_data['SMA_Strategy_Returns'] + 1).cumprod() - 1

Computes the Simple Moving Average of the closing prices over a specified lookback period (10 periods) and stores it in the 'SMA' column.
If the closing price is greater than or equal to the SMA, it assigns a signal value of 1 (long position); otherwise, it assigns -1 (short position) to the 'SMA_Signal' column. Calculates strategy returns by multiplying daily log returns with the SMA strategy signal shifted by one day. Any NaN values resulting from the shift are filled with 0.

plt.figure(figsize=(20, 8))
plt.plot(ohlc_data['timestamp'], ohlc_data['SMA_Cumulative_Returns'], label='Single Moving Average', color='blue')
plt.plot(ohlc_data['timestamp'], ohlc_data['MACD_Cumulative_Returns'], label='MACD Cumulative Returns', color='black')
plt.plot(ohlc_data['timestamp'], ohlc_data['RSI_Cumulative_Returns'], label='RSI', color='green')
plt.plot(ohlc_data['timestamp'], ohlc_data['Breakout_Cumulative_Returns'], label='Breakout Strategy', color='red')
plt.plot(ohlc_data['timestamp'], ohlc_data['Bollinger_Bands_Cumulative_Returns'], label='Bollinger Bands', color='purple')
plt.xlabel('Date')
plt.ylabel('Cumulative Returns')
plt.title('Cumulative Returns of Different Strategies')
plt.xticks(rotation=45)
plt.legend()
plt.grid(True, linestyle='--', alpha=0.7)
plt.tight_layout()
plt.show()

Plots the cumulative returns of all four strategies (SMA, RSI, Breakout, MACD and Bollinger Bands) on the same plot for visual comparison.

When it comes to Ofelya_Rzayeva_221223910.py

# API credentials
ClientID = "5_I8ZjVe"
ClientSecret = "4U0aLbG9o5OMCCKoVdKwJRVKzswNRGIVItfoDXYibT0"

# Helper function to get market data
def get_market(instrument):
    url = "https://www.deribit.com/api/v2/public/get_book_summary_by_instrument"
    params = {
        "instrument_name": instrument
    }
    response = requests.get(url, params=params)

    if response.status_code == 200:
        data = response.json()
        print('Download market data was successful')
    else:
        print(f"Failed to retrieve data: {response.status_code}")

    market_data = pd.DataFrame(data["result"])
    market_price = int(market_data['mark_price'].values[0].round(-1))
    
    print(f"Current market price: {market_price}")
    
    return market_price

This function get_market(instrument) is defined to retrieve market data for a given instrument. It makes a GET request to the Deribit API endpoint with the specified instrument name. If the response status code is 200 (indicating a successful request), the market data is extracted and stored in a DataFrame. The market price is then extracted from the DataFrame and rounded to the nearest tenth.
Finally, the current market price is printed and returned from the function.

Helper function to place a sell order
def sell(params):
    url = "https://test.deribit.com/api/v2/private/sell"
    response = requests.get(url, params=params, auth=(ClientID, ClientSecret))
    
    if response.status_code == 200:
        data = response.json()
        print(f"Trade was successful: {data['result']}")
    else:
        print(f"Failed to trade: {response.status_code}")

This function sell(params) is defined to place a sell order. It makes a GET request to the specified URL endpoint (https://test.deribit.com/api/v2/private/sell) with the given parameters (params) and API authentication using the ClientID and ClientSecret.

# Calculate breakout prices (Thomas N. B., 2005)
instrument_name = "BTC-PERPETUAL" #is set to "BTC-PERPETUAL" representing the instrument or asset.
threshold_percentage = 2.0 #is set to 2.0, indicating a 2% threshold for the breakout.
# Get the current market price
market_price = get_market(instrument_name) #The code then calls the function to retrieve the current market price of the instrument.
# Calculate breakout threshold
threshold = market_price * threshold_percentage / 100 #Next, the breakout threshold is calculated by multiplying the market price by the threshold percentage divided by 100.

# Determine breakout prices
breakout_high = market_price + threshold
breakout_low = market_price - threshold
print("Breakout prices:")
print(f"Breakout High: {breakout_high}")
print(f"Breakout Low: {breakout_low}")

#Finally, the breakout high and breakout low prices are determined by adding and subtracting the threshold from the market price, respectively. The calculated breakout prices are then printed.

# Define the parameters for the sell order
params = {
    "amount": market_price, # is set to the market price, which represents the amount to be sold.
    "instrument_name": instrument_name, #is set to the instrument name ("BTC-PERPETUAL") for which the sell order is placed.
    "type": "market" #is set to "market" indicating a market order.
}

# Place the sell order
sell(params) #function is then called, passing the params dictionary as an argument.This function executes
             #a sell order using the specified parameters and provides feedback on the success or failure of the trade.
             
class DataHandler:
    def __init__(self, db_name):
        self.engine = create_engine(f'sqlite:///{db_name}')  # Create a SQLite database engine

    def download(self, instrument_name):
        url = "https://www.deribit.com/api/v2/public/get_tradingview_chart_data"
        params = {
            "instrument_name": instrument_name,
            "end_timestamp": int(time.time() * 1000),  # In Epoch milliseconds
            "start_timestamp": int((time.time() - 1e6) * 1000),  # In Epoch milliseconds
            "resolution": "60"  # Minute data
        }
        response = requests.get(url, params=params)  # Send a GET request to the API
        data = response.json()  # Extract the JSON response

        print(data)  # Print the response data to inspect its structure

        if 'error' in data:  # Check if the response contains an error
            print(f"Error: {data['error']['message']}")
            return

        if 'result' in data and instrument_name in data['result']:
            ohlc_data = data['result'][instrument_name]  # Extract the OHLC data
            ohlc = pd.DataFrame(ohlc_data)  # Create a DataFrame from the OHLC data
            ohlc['timestamp'] = pd.to_datetime(ohlc['ticks'], unit='ms')  # Convert the timestamp to datetime format
            ohlc['instrument_name'] = instrument_name  # Add instrument name column
            ohlc['resolution'] = 60  # Add resolution column
            ohlc.to_sql('ohlc', self.engine, if_exists='replace')  # Store the data in the 'ohlc' table of the database
            print(f"Downloaded data for {instrument_name}")
        else:
            print(f"No data found for {instrument_name}")

    def select(self, query):
        return pd.read_sql(query, self.engine)  # Execute a SQL query and return the results as a DataFrame

    def plot(self, query):
        df = self.select(query)  # Retrieve data based on the query
        df.set_index('timestamp', inplace=True)  # Set 'timestamp' as the index
        df.plot()  # Plot the data
        plt.title(f'{query}')  # Set the title of the plot
        plt.xlabel('Date')  # Set the label for the x-axis
        plt.show()  # Display the plot

dh = DataHandler('07_datam.db')  # Create an instance of DataHandler with the specified database name

data = dh.select('SELECT * FROM ohlc')  # Retrieve the data from the 'ohlc' table in the database

The constructor initializes the DataHandler object and creates a connection to a SQLite database using the specified database name (db_name). It sets up the engine to interact with the database.
Retrieving trading data for a specific financial instrument (instrument_name) from the Deribit API. It makes a GET request to the API with the necessary parameters, such as the instrument name, start and end timestamps, and data resolution. The retrieved data is then converted into a DataFrame and stored in the SQLite database with the table name 'ohlc'.
The select method allows executing SQL queries on the SQLite database. It takes a query as input and returns the results as a DataFrame.
The query is used to specify the data to be plotted, and the method creates a plot with the 'timestamp' as the x-axis and the specified data as the y-axis. The title of the plot is set to the query string.
Finally, the code creates an instance of the DataHandler class with the database name '07_datam.db' and then retrieves data from the 'ohlc' table in the database using the select method with the query 'SELECT * FROM ohlc'.

The reason why I have given information about backtest I will not do it again here.

# Read the CSV file
df = pd.read_csv('transaction_log.csv')

# Convert 'Date' column to pandas Timestamp
df['Date'] = pd.to_datetime(df['Date'])

# Set the desired start date
start_date = pd.Timestamp(2023, 7, 9, 10, 11)

# Filter the dataframe for the desired start date and actions
df_filtered = df[df['Date'] >= start_date]
df_open_sell = df_filtered[df_filtered['Side'] == 'open sell']
df_close_buy = df_filtered[df_filtered['Side'] == 'close buy']
df_short = df_filtered[df_filtered['Side'] == 'short']
# Set up the figure and axes
fig, ax = plt.subplots(figsize=(10, 6))
# Plot the trade positions as scatter points
ax.scatter(df_open_sell['Date'], df_open_sell['Price'], marker='o', color='red', label='Open Sell', s=30, alpha=0.7)
ax.scatter(df_close_buy['Date'], df_close_buy['Price'], marker='o', color='blue', label='Close Buy', s=30, alpha=0.7)
ax.scatter(df_short['Date'], df_short['Price'], marker='o', color='green', label='Short', s=30, alpha=0.7)
# Plot the "price" as a line
ax.plot(df_filtered['Date'], df_filtered['Price'], color='orange', label='Price', linewidth=2)
# Set plot labels and title
ax.set_xlabel('Date')
ax.set_ylabel('Price')
ax.set_title('Trade Positions')
# Customize tick labels
ax.xaxis.set_major_locator(mdates.DayLocator())
ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d'))
ax.tick_params(axis='x', rotation=45)
ax.tick_params(axis='both', labelsize=10)
# Add a grid
ax.grid(True, linestyle='--', alpha=0.5)
# Add legend with a shadow
ax.legend(frameon=True, shadow=True)
# Remove spines
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
# Adjust plot margins
plt.tight_layout()
# Show the plot
plt.show()

The provided code reads data from a CSV file named 'transaction_log.csv', which likely contains information about various transactions. It then filters the data to plot trade positions based on different actions such as 'open sell', 'close buy', and 'short'. The trade positions are plotted as scatter points with different colors, and the price data is shown as a line.

# Filter the dataframe for the desired start date and actions
df_filtered = df[df['Date'] >= start_date]
# Plot the equity changes over time
plt.figure(figsize=(15, 6))
plt.plot(df_filtered['Date'], df_filtered['Equity'])
plt.title('Equity Changes over Time')
plt.xlabel('Date')
plt.ylabel('Equity')
plt.xticks(rotation=45)
plt.show()

In the provided code, the DataFrame df is filtered based on a desired start date (start_date) using boolean indexing. The filtered DataFrame is then used to plot the changes in equity over time.

In order to show I am able to pull date online and I can also use cvs file I have used both way to retrieve data

# Define the URL of the endpoint
url = "https://test.deribit.com/api/v2/private/get_transaction_log"

start_date = pd.Timestamp(2023, 7, 9, 10, 11, 0)

# Start date can be set individually (e.g., 9 days before today)
start_date = int((datetime.now(timezone.utc) - timedelta(days=9)).timestamp() * 1e3) # Required type: integer
end_date = int(datetime.utcnow().timestamp() * 1e3)  # End date is set to the current timestamp
# Define the parameters
params = {
    "currency": "BTC",
    "start_timestamp": start_date,
    "end_timestamp": end_date
}

# Send the GET request
response = requests.get(url, params=params, auth=(ClientID, ClientSecret))
json_response = response.json()
data = json_response['result']
# Convert results to a DataFrame
df = json_normalize(data, 'logs')
# Filter for settlements only
df_settlement = df[df['type'] == 'settlement']

n the provided code, a GET request is sent to a specific API endpoint (https://test.deribit.com/api/v2/private/get_transaction_log) to retrieve transaction logs related to settlements. These logs are specific to the cryptocurrency "BTC" (Bitcoin) and cover a time period defined by a start date (start_date) and an end date (end_date).


Literature

To pulling data 07_datam_solutions.ipynb, 08_datam_solutions.ipynb
"Technical Analysis of the Financial Markets: A Comprehensive Guide to Trading Methods and Applications" by John J. Murphy September 22, 1999
"Technical Analysis Explained: The Successful Investor's Guide to Spotting Investment Trends and Turning Points" by Martin J. Pring
 December 22, 2002
"Encyclopedia of Chart Patterns" by Thomas N. Bulkowski June 12, 2005
"Bollinger on Bollinger Bands" by John Bollinger September 1, 2001
https://www.investopedia.com/articles/forex/05/macddiverge.asp#:~:text=Moving%20average%20convergence%20divergence%20is,and%20exit%20points%20for%20trades.
To write an introduction for "Live paper-trading" I have used ChatGBT.
To explain ratios in "Live paper-trading" Investment Valuation: Tools and Techniques for Determining the Value of Any Asset, 3rd Edition, Aswath Damodaran April 2012
